\chapter{Antarmuka API Proses}
\vspace{1cm}

Pada bab sebelumnya, kita membahas abstraksi proses dan bagaimana OS menciptakan ilusi banyak CPU. Pada bab ini, fokus kita adalah antarmuka pemrograman yang digunakan aplikasi untuk berinteraksi dengan proses di sistem UNIX: bagaimana proses dibuat, bagaimana proses menunggu proses lain, dan bagaimana program baru dijalankan dalam ruang proses yang sudah ada.

Secara praktis, ada tiga system call yang menjadi fondasi API proses:
\begin{itemize}
    \item \texttt{fork()} untuk membuat proses baru,
    \item \texttt{wait()} / \texttt{waitpid()} untuk menunggu proses anak selesai,
    \item \texttt{exec()} (keluarga \texttt{exec}) untuk mengganti citra program yang sedang berjalan.
\end{itemize}

\begin{asidebox}{INTI MASALAH: \\ BAGAIMANA PROGRAM MEMBUAT DAN MENGELOLA PROSES?}
Jika proses adalah abstraksi utama untuk virtualisasi CPU, maka bagaimana aplikasi benar-benar membuat proses baru? Bagaimana hubungan induk--anak dibentuk? Bagaimana sinkronisasi dilakukan agar proses induk tahu kapan anak selesai? Dan bagaimana proses memulai program yang berbeda tanpa membuat proses dari nol?
\end{asidebox}

\section{System Call \texttt{fork()}}
\texttt{fork()} membuat salinan proses pemanggil. Setelah pemanggilan berhasil, akan ada \textbf{dua} proses yang melanjutkan eksekusi dari baris setelah \texttt{fork()}: proses induk (\textit{parent}) dan proses anak (\textit{child}).

Perilaku kunci dari \texttt{fork()} adalah nilai kembaliannya:
\begin{itemize}
    \item Pada proses \textit{child}, nilai kembali \texttt{fork()} adalah 0.
    \item Pada proses \textit{parent}, nilai kembali \texttt{fork()} adalah PID anak (bilangan positif).
    \item Jika gagal, \texttt{fork()} mengembalikan nilai negatif.
\end{itemize}

\begin{lstlisting}[language=C, caption={Contoh dasar penggunaan \texttt{fork()}}, label={lst:fork-basic}]
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    printf("halo (pid:%d)\n", (int)getpid());

    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork gagal\n");
        exit(1);
    } else if (rc == 0) {
        printf("saya child (pid:%d)\n", (int)getpid());
    } else {
        printf("saya parent dari child %d (pid:%d)\n", rc, (int)getpid());
    }

    return 0;
}
\end{lstlisting}

Karena parent dan child berjalan secara konkuren, urutan keluaran keduanya tidak dijamin sama di setiap eksekusi. Inilah contoh awal bahwa \textbf{penjadwal OS} menentukan siapa yang mendapat CPU lebih dulu.

\section{Ruang Alamat Setelah \texttt{fork()}}
Meskipun \texttt{fork()} terlihat seperti menyalin seluruh proses, implementasi modern biasanya menggunakan teknik \textit{copy-on-write} agar efisien. Secara semantik, parent dan child memiliki ruang alamat terpisah: perubahan variabel di child tidak mengubah salinan variabel di parent, dan sebaliknya.

\begin{lstlisting}[language=C, caption={Variabel yang tampak sama tetapi hidup di proses berbeda}, label={lst:fork-memory}]
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int x = 100;

int main(void) {
    int rc = fork();
    if (rc < 0) {
        exit(1);
    } else if (rc == 0) {
        x = 200;
        printf("child: x=%d (pid:%d)\n", x, (int)getpid());
    } else {
        x = 300;
        printf("parent: x=%d (pid:%d)\n", x, (int)getpid());
    }
    return 0;
}
\end{lstlisting}

Kode di atas menegaskan bahwa proses adalah unit isolasi: masing-masing memiliki konteks eksekusi sendiri (register, ruang alamat, status file, dan metadata proses).

\section{System Call \texttt{wait()} dan \texttt{waitpid()}}
Sering kali parent perlu menunggu child selesai sebelum melanjutkan. Untuk itu, UNIX menyediakan \texttt{wait()} atau \texttt{waitpid()}.

\begin{lstlisting}[language=C, caption={Parent menunggu child selesai}, label={lst:wait}]
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main(void) {
    int rc = fork();
    if (rc < 0) {
        exit(1);
    } else if (rc == 0) {
        printf("child berjalan (pid:%d)\n", (int)getpid());
    } else {
        int wc = wait(NULL);
        printf("parent (pid:%d): child %d selesai\n", (int)getpid(), wc);
    }
    return 0;
}
\end{lstlisting}

Dengan \texttt{wait()}, parent diblokir sampai salah satu child selesai. Ini adalah pola sinkronisasi sederhana tetapi sangat umum, misalnya pada shell ketika menjalankan program di mode \textit{foreground}.

\section{System Call Keluarga \texttt{exec()}}
\texttt{fork()} membuat proses baru yang awalnya mengeksekusi kode yang sama dengan parent. Namun, pada banyak kasus kita ingin child menjalankan program \textbf{lain}. Di sinilah \texttt{exec()} digunakan.

Keluarga \texttt{exec} (misalnya \texttt{execl()}, \texttt{execvp()}) \textbf{mengganti} citra proses saat ini dengan program baru. Jika berhasil, kode lama tidak dilanjutkan.

\begin{lstlisting}[language=C, caption={Menggabungkan \texttt{fork()} dan \texttt{execvp()}}, label={lst:exec}]
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    int rc = fork();
    if (rc < 0) {
        exit(1);
    } else if (rc == 0) {
        char *myargs[3];
        myargs[0] = "wc";
        myargs[1] = "chapter3-book-translate.tex";
        myargs[2] = NULL;
        execvp(myargs[0], myargs);
        printf("baris ini tidak tercetak jika exec berhasil\n");
    } else {
        wait(NULL);
        printf("parent: child selesai\n");
    }
    return 0;
}
\end{lstlisting}

Pola \texttt{fork()} lalu \texttt{exec()} adalah dasar implementasi shell UNIX. Shell membuat child, child memanggil \texttt{exec()}, lalu parent menunggu (atau tidak menunggu untuk \textit{background job}).

\section{Mengapa API Proses Dirancang Seperti Ini?}
Desain ini terkenal karena sederhana namun sangat fleksibel:
\begin{itemize}
    \item \texttt{fork()} memisahkan langkah \textit{membuat proses} dari langkah \textit{menjalankan program baru}.
    \item Antara \texttt{fork()} dan \texttt{exec()}, child bisa melakukan pengaturan lanjutan: mengubah direktori kerja, mengatur \textit{file descriptor}, mengalihkan I/O, dan sebagainya.
    \item \texttt{wait()} memberi kontrol sinkronisasi yang jelas kepada parent.
\end{itemize}

Kombinasi ini membuat banyak fitur sistem mudah dibangun, seperti pipa antar-proses, redireksi file, \textit{job control}, dan daemon.

\section{Redireksi Output dan Pipe}
Pemisahan \texttt{fork()} dan \texttt{exec()} memungkinkan shell menyiapkan lingkungan child sebelum program baru dijalankan. Contoh paling umum adalah redireksi keluaran:
\begin{itemize}
    \item Shell membuat child dengan \texttt{fork()}.
    \item Di child, \texttt{STDOUT\_FILENO} ditutup.
    \item Shell membuka file tujuan, sehingga descriptor terendah yang kosong (biasanya 1) dipakai untuk file tersebut.
    \item Child memanggil \texttt{exec()}, dan keluaran program otomatis mengarah ke file.
\end{itemize}

\begin{lstlisting}[language=C, caption={Sketsa redireksi sebelum \texttt{exec()}}, label={lst:redirection}]
#include <fcntl.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main(void) {
    int rc = fork();
    if (rc < 0) return 1;

    if (rc == 0) {
        close(STDOUT_FILENO);
        open("./hasil.txt", O_CREAT | O_WRONLY | O_TRUNC, 0700);

        char *args[] = {"wc", "chapter3-book-translate.tex", NULL};
        execvp(args[0], args);
        exit(1);
    }

    wait(NULL);
    return 0;
}
\end{lstlisting}

Konsep yang sama dipakai untuk \textit{pipe}: keluaran proses pertama dihubungkan ke masukan proses kedua melalui \texttt{pipe()} dan pengaturan descriptor file. Karena itu shell bisa membangun rantai perintah seperti \texttt{grep -o kata file | wc -l}.

\section{Kontrol Proses Dengan Sinyal}
Selain membuat dan menunggu proses, UNIX menyediakan mekanisme kontrol lewat \textit{signal}. Dengan \texttt{kill()} (atau utilitas shell seperti \texttt{kill}/\texttt{killall}), proses dapat menerima sinyal untuk:
\begin{itemize}
    \item menghentikan proses (misalnya \texttt{SIGINT}),
    \item menjeda proses (\texttt{SIGTSTP}),
    \item melanjutkan proses yang dijeda (\texttt{SIGCONT}),
    \item atau tindakan lain tergantung jenis sinyal.
\end{itemize}

Pada shell interaktif, kombinasi tombol seperti \texttt{Ctrl-C} dan \texttt{Ctrl-Z} pada dasarnya mengirim sinyal ke proses \textit{foreground}. Program juga bisa memasang handler (misalnya lewat \texttt{signal()}) untuk merespons sinyal tertentu.

\section{Pengguna, Hak Akses, dan Superuser}
Kontrol proses selalu terkait model pengguna (\textit{user}) di sistem operasi:
\begin{itemize}
    \item User biasa umumnya hanya boleh mengontrol proses miliknya sendiri.
    \item OS memakai batasan ini untuk keamanan dan isolasi antar-user.
    \item Superuser (\texttt{root}) dapat mengontrol proses user lain dan menjalankan operasi administratif.
\end{itemize}

Kewenangan \texttt{root} kuat, tetapi berisiko jika salah pakai. Praktik yang aman adalah memakai akun biasa untuk pekerjaan harian dan naik hak akses hanya saat benar-benar perlu.

\section{Alat Praktis untuk Observasi Proses}
Beberapa tool command-line yang sering dipakai:
\begin{itemize}
    \item \texttt{ps}: melihat daftar proses yang sedang berjalan.
    \item \texttt{top}: memantau pemakaian CPU/memori secara real-time.
    \item \texttt{kill} / \texttt{killall}: mengirim sinyal ke proses.
\end{itemize}

Tool-tool ini melengkapi pemahaman API proses: bukan hanya bagaimana proses dibuat, tetapi juga bagaimana proses dipantau dan dikendalikan saat sistem berjalan.

\begin{asidebox}{INTI MASALAH: \\ BAGAIMANA SHELL MENJALANKAN PERINTAH?}
Shell modern bergantung pada tiga primitive ini: \texttt{fork()}, \texttt{exec()}, dan \texttt{wait()}. Dengan primitive sederhana tersebut, shell dapat mengeksekusi perintah pengguna, mengatur proses latar depan/latar belakang, serta menghubungkan keluaran dan masukan antar-program.
\end{asidebox}

\section{Ringkasan}
Bab ini memperkenalkan API proses pada sistem UNIX. Kita mempelajari bahwa \texttt{fork()} membuat proses anak, \texttt{wait()} menyinkronkan parent dengan child, dan \texttt{exec()} mengganti program yang dijalankan oleh suatu proses. Kita juga melihat mengapa pemisahan \texttt{fork()} dan \texttt{exec()} penting untuk membangun fitur shell seperti redireksi dan \textit{pipe}, bagaimana proses dikontrol melalui sinyal, serta bagaimana model user/root membatasi hak kontrol proses. Secara praktis, kombinasi API dan tool observasi seperti \texttt{ps}, \texttt{top}, dan \texttt{kill} adalah fondasi kerja sehari-hari dalam sistem operasi UNIX modern.
